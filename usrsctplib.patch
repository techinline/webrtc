From b1166d36f6b14a2c61cc3f6520922af72cf9bbe9 Mon Sep 17 00:00:00 2001
From: Igor Ulitin <iulitin@techinline.com>
Date: Mon, 7 Sep 2020 10:59:45 +0400
Subject: [PATCH] patch

---
 usrsctplib/netinet/sctp_cc_functions.c | 118 +++++++++----------------
 usrsctplib/netinet/sctp_constants.h    |   2 +-
 usrsctplib/netinet/sctp_input.c        |  15 ++++
 usrsctplib/netinet/sctp_sysctl.h       |   8 +-
 usrsctplib/netinet/sctp_usrreq.c       |   5 +-
 usrsctplib/netinet/sctp_var.h          |   2 +
 usrsctplib/netinet/sctputil.c          |   7 ++
 7 files changed, 71 insertions(+), 86 deletions(-)

diff --git a/usrsctplib/netinet/sctp_cc_functions.c b/usrsctplib/netinet/sctp_cc_functions.c
index 0139057..5772134 100755
--- a/usrsctplib/netinet/sctp_cc_functions.c
+++ b/usrsctplib/netinet/sctp_cc_functions.c
@@ -64,10 +64,7 @@ sctp_enforce_cwnd_limit(struct sctp_association *assoc, struct sctp_nets *net)
 	if ((assoc->max_cwnd > 0) &&
 	    (net->cwnd > assoc->max_cwnd) &&
 	    (net->cwnd > (net->mtu - sizeof(struct sctphdr)))) {
-		net->cwnd = assoc->max_cwnd ;
-		if (net->cwnd < (net->mtu - sizeof(struct sctphdr))) {
-			net->cwnd = net->mtu - sizeof(struct sctphdr);
-		}
+		net->cwnd = SCTP_CWND_SIZE ;
 	}
 }
 
@@ -79,26 +76,12 @@ sctp_set_initial_cc_param(struct sctp_tcb *stcb, struct sctp_nets *net)
 
 	assoc = &stcb->asoc;
 	cwnd_in_mtu = SCTP_BASE_SYSCTL(sctp_initial_cwnd);
-	if (cwnd_in_mtu == 0) {
-		/* Using 0 means that the value of RFC 4960 is used. */
-		net->cwnd = min((net->mtu * 4), max((2 * net->mtu), SCTP_INITIAL_CWND));
-	} else {
-		/*
-		 * We take the minimum of the burst limit and the
-		 * initial congestion window.
-		 */
-		if ((assoc->max_burst > 0) && (cwnd_in_mtu > assoc->max_burst))
-			cwnd_in_mtu = assoc->max_burst;
-		net->cwnd = (net->mtu - sizeof(struct sctphdr)) * cwnd_in_mtu;
-	}
-	if ((stcb->asoc.sctp_cmt_on_off == SCTP_CMT_RPV1) ||
-	    (stcb->asoc.sctp_cmt_on_off == SCTP_CMT_RPV2)) {
-		/* In case of resource pooling initialize appropriately */
-		net->cwnd /= assoc->numnets;
-		if (net->cwnd < (net->mtu - sizeof(struct sctphdr))) {
-			net->cwnd = net->mtu - sizeof(struct sctphdr);
-		}
-	}
+
+	if ((cwnd_in_mtu != 0) && (assoc->max_burst > 0) && (cwnd_in_mtu > assoc->max_burst))
+		cwnd_in_mtu = assoc->max_burst;
+
+	net->cwnd = SCTP_CWND_SIZE;
+
 	sctp_enforce_cwnd_limit(assoc, net);
 	net->ssthresh = assoc->peers_rwnd;
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
@@ -194,7 +177,7 @@ sctp_cwnd_update_after_fr(struct sctp_tcb *stcb,
 						net->ssthresh = 2 * net->mtu;
 					}
 				}
-				net->cwnd = net->ssthresh;
+				net->cwnd = SCTP_CWND_SIZE;
 				sctp_enforce_cwnd_limit(asoc, net);
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 				SDT_PROBE5(sctp, cwnd, net, fr,
@@ -309,7 +292,7 @@ cc_bw_same(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_nets *net, uint64_t nb
 					  probepoint);
 #endif
 				if (net->cwnd > (4 * net->mtu)) {
-					net->cwnd -= net->mtu;
+					net->cwnd = SCTP_CWND_SIZE;
 					net->cc_mod.rtcc.vol_reduce++;
 				} else {
 					net->cc_mod.rtcc.step_cnt = 0;
@@ -391,7 +374,7 @@ cc_bw_same(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_nets *net, uint64_t nb
 		     ((net->cc_mod.rtcc.step_cnt % net->cc_mod.rtcc.steady_step) == 0))) {
 			/* Try a step down */
 			if (net->cwnd > (4 * net->mtu)) {
-				net->cwnd -= net->mtu;
+				net->cwnd = SCTP_CWND_SIZE;
 				net->cc_mod.rtcc.vol_reduce++;
 				return (1);
 			} else {
@@ -478,7 +461,7 @@ cc_bw_decrease(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_nets *net, uint64_
 			 */
 			if ((net->cc_mod.rtcc.vol_reduce) &&
 			    (inst_ind != SCTP_INST_GAINING)) {
-				net->cwnd += net->mtu;
+				net->cwnd = SCTP_CWND_SIZE;
 				sctp_enforce_cwnd_limit(&stcb->asoc, net);
 				net->cc_mod.rtcc.vol_reduce--;
 			}
@@ -514,7 +497,7 @@ cc_bw_decrease(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_nets *net, uint64_
 #endif
 			if ((net->cc_mod.rtcc.vol_reduce) &&
 			    (inst_ind != SCTP_INST_GAINING)) {
-				net->cwnd += net->mtu;
+				net->cwnd = SCTP_CWND_SIZE;
 				sctp_enforce_cwnd_limit(&stcb->asoc, net);
 				net->cc_mod.rtcc.vol_reduce--;
 			}
@@ -550,7 +533,7 @@ cc_bw_decrease(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_nets *net, uint64_
 #endif
 		if ((net->cc_mod.rtcc.vol_reduce) &&
 		    (inst_ind != SCTP_INST_GAINING)) {
-			net->cwnd += net->mtu;
+			net->cwnd = SCTP_CWND_SIZE;
 			sctp_enforce_cwnd_limit(&stcb->asoc, net);
 			net->cc_mod.rtcc.vol_reduce--;
 		}
@@ -981,7 +964,7 @@ sctp_cwnd_update_after_sack_common(struct sctp_tcb *stcb,
 						}
 						break;
 					}
-					net->cwnd += incr;
+					net->cwnd = SCTP_CWND_SIZE;
 					sctp_enforce_cwnd_limit(asoc, net);
 					if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 						sctp_log_cwnd(stcb, net, incr,
@@ -1049,7 +1032,7 @@ sctp_cwnd_update_after_sack_common(struct sctp_tcb *stcb,
 						incr = net->mtu;
 						break;
 					}
-					net->cwnd += incr;
+					net->cwnd = SCTP_CWND_SIZE;
 					sctp_enforce_cwnd_limit(asoc, net);
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 					SDT_PROBE5(sctp, cwnd, net, ack,
@@ -1091,7 +1074,7 @@ sctp_cwnd_update_exit_pf_common(struct sctp_tcb *stcb SCTP_UNUSED, struct sctp_n
 
 	old_cwnd = net->cwnd;
 #endif
-	net->cwnd = net->mtu;
+	net->cwnd = SCTP_CWND_SIZE;
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 	SDT_PROBE5(sctp, cwnd, net, ack,
 	          stcb->asoc.my_vtag, ((stcb->sctp_ep->sctp_lport << 16) | (stcb->rport)), net,
@@ -1163,7 +1146,7 @@ sctp_cwnd_update_after_timeout(struct sctp_tcb *stcb, struct sctp_nets *net)
 	} else {
 		net->ssthresh = max(net->cwnd / 2, 4 * net->mtu);
 	}
-	net->cwnd = net->mtu;
+	net->cwnd = SCTP_CWND_SIZE;
 	net->partial_bytes_acked = 0;
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 	SDT_PROBE5(sctp, cwnd, net, to,
@@ -1187,14 +1170,8 @@ sctp_cwnd_update_after_ecn_echo_common(struct sctp_tcb *stcb, struct sctp_nets *
 		if (in_window == 0) {
 			/* Go to CA with the cwnd at the point we sent
 			 * the TSN that was marked with a CE.
-			 */
-			if (net->ecn_prev_cwnd < net->cwnd) {
-				/* Restore to prev cwnd */
-				net->cwnd = net->ecn_prev_cwnd - (net->mtu * num_pkt_lost);
-			} else {
-				/* Just cut in 1/2 */
-				net->cwnd /= 2;
-			}
+			 */			
+			net->cwnd = SCTP_CWND_SIZE;
 			/* Drop to CA */
 			net->ssthresh = net->cwnd - (num_pkt_lost * net->mtu);
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
@@ -1203,7 +1180,7 @@ sctp_cwnd_update_after_ecn_echo_common(struct sctp_tcb *stcb, struct sctp_nets *
 		} else {
 			/* Further tuning down required over the drastic original cut */
 			net->ssthresh -= (net->mtu * num_pkt_lost);
-			net->cwnd -= (net->mtu * num_pkt_lost);
+			net->cwnd = SCTP_CWND_SIZE;
 			if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 				sctp_log_cwnd(stcb, net, (net->cwnd - old_cwnd), SCTP_CWND_LOG_FROM_SAT);
 			}
@@ -1219,7 +1196,7 @@ sctp_cwnd_update_after_ecn_echo_common(struct sctp_tcb *stcb, struct sctp_nets *
 				/* here back off the timer as well, to slow us down */
 				net->RTO <<= 1;
 			}
-			net->cwnd = net->ssthresh;
+			net->cwnd = SCTP_CWND_SIZE;
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 			SDT_PROBE5(sctp, cwnd, net, ecn,
 				  stcb->asoc.my_vtag,
@@ -1283,7 +1260,7 @@ sctp_cwnd_update_after_packet_dropped(struct sctp_tcb *stcb,
 			 * undo any cwnd adjustment that the sack
 			 * might have made
 			 */
-			net->cwnd = net->prev_cwnd;
+			net->cwnd = SCTP_CWND_SIZE;
 		}
 		/* Now how much of that is mine? */
 		seg_inflight = net->flight_size / net->mtu;
@@ -1310,12 +1287,8 @@ sctp_cwnd_update_after_packet_dropped(struct sctp_tcb *stcb,
 		 * had a sack before this packet). minus what ever
 		 * portion of the overage is my fault.
 		 */
-		net->cwnd -= my_portion;
+		net->cwnd = SCTP_CWND_SIZE;
 
-		/* we will NOT back down more than 1 MTU */
-		if (net->cwnd <= net->mtu) {
-			net->cwnd = net->mtu;
-		}
 		/* force into CA */
 		net->ssthresh = net->cwnd - 1;
 	} else {
@@ -1328,16 +1301,11 @@ sctp_cwnd_update_after_packet_dropped(struct sctp_tcb *stcb,
 		    (stcb->asoc.max_burst * net->mtu < incr)) {
 			incr = stcb->asoc.max_burst * net->mtu;
 		}
-		net->cwnd += incr;
-	}
-	if (net->cwnd > bw_avail) {
-		/* We can't exceed the pipe size */
-		net->cwnd = bw_avail;
-	}
-	if (net->cwnd < net->mtu) {
-		/* We always have 1 MTU */
-		net->cwnd = net->mtu;
+		net->cwnd = SCTP_CWND_SIZE;
 	}
+	
+	net->cwnd = SCTP_CWND_SIZE;
+
 	sctp_enforce_cwnd_limit(&stcb->asoc, net);
 	if (net->cwnd - old_cwnd != 0) {
 		/* log only changes */
@@ -1364,7 +1332,7 @@ sctp_cwnd_update_after_output(struct sctp_tcb *stcb,
 	if (net->ssthresh < net->cwnd)
 		net->ssthresh = net->cwnd;
 	if (burst_limit) {
-		net->cwnd = (net->flight_size + (burst_limit * net->mtu));
+		net->cwnd = SCTP_CWND_SIZE;
 		sctp_enforce_cwnd_limit(&stcb->asoc, net);
 #if defined(__FreeBSD__) && __FreeBSD_version >= 803000
 		SDT_PROBE5(sctp, cwnd, net, bl,
@@ -1484,7 +1452,7 @@ sctp_cwnd_new_rtcc_transmission_begins(struct sctp_tcb *stcb,
 			}
 			if (net->cwnd > cwnd) {
 				/* Only set if we are not a timeout (i.e. down to 1 mtu) */
-				net->cwnd = cwnd;
+				net->cwnd = SCTP_CWND_SIZE;
 			}
 		}
 	}
@@ -1712,11 +1680,7 @@ sctp_hs_cwnd_increase(struct sctp_tcb *stcb, struct sctp_nets *net)
 
 	if (cur_val < sctp_cwnd_adjust[0].cwnd) {
 		/* normal mode */
-		if (net->net_ack > net->mtu) {
-			net->cwnd += net->mtu;
-		} else {
-			net->cwnd += net->net_ack;
-		}
+		net->cwnd = SCTP_CWND_SIZE;
 	} else {
 		for (i = net->last_hs_used; i < SCTP_HS_TABLE_SIZE; i++) {
 			if (cur_val < sctp_cwnd_adjust[i].cwnd) {
@@ -1726,7 +1690,7 @@ sctp_hs_cwnd_increase(struct sctp_tcb *stcb, struct sctp_nets *net)
 		}
 		net->last_hs_used = indx;
 		incr = (((int32_t)sctp_cwnd_adjust[indx].increase) << 10);
-		net->cwnd += incr;
+		net->cwnd = SCTP_CWND_SIZE;
 	}
 	sctp_enforce_cwnd_limit(&stcb->asoc, net);
 	if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
@@ -1747,12 +1711,12 @@ sctp_hs_cwnd_decrease(struct sctp_tcb *stcb, struct sctp_nets *net)
 		if (net->ssthresh < (net->mtu * 2)) {
 			net->ssthresh = 2 * net->mtu;
 		}
-		net->cwnd = net->ssthresh;
+		net->cwnd = SCTP_CWND_SIZE;
 	} else {
 		/* drop by the proper amount */
 		net->ssthresh = net->cwnd - (int)((net->cwnd / 100) *
 		    (int32_t)sctp_cwnd_adjust[net->last_hs_used].drop_percent);
-		net->cwnd = net->ssthresh;
+		net->cwnd = SCTP_CWND_SIZE;
 		/* now where are we */
 		indx = net->last_hs_used;
 		cur_val = net->cwnd >> 10;
@@ -1912,7 +1876,7 @@ sctp_hs_cwnd_update_after_sack(struct sctp_tcb *stcb,
 				if ((net->flight_size + net->net_ack >= net->cwnd) &&
 				    (net->partial_bytes_acked >= net->cwnd)) {
 					net->partial_bytes_acked -= net->cwnd;
-					net->cwnd += net->mtu;
+					net->cwnd = SCTP_CWND_SIZE;
 					sctp_enforce_cwnd_limit(asoc, net);
 					if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 						sctp_log_cwnd(stcb, net, net->mtu,
@@ -2138,14 +2102,14 @@ htcp_cong_avoid(struct sctp_tcb *stcb, struct sctp_nets *net)
 		/* We are in slow start */
 		if (net->flight_size + net->net_ack >= net->cwnd) {
 			if (net->net_ack > (net->mtu * SCTP_BASE_SYSCTL(sctp_L2_abc_variable))) {
-				net->cwnd += (net->mtu * SCTP_BASE_SYSCTL(sctp_L2_abc_variable));
+				net->cwnd = SCTP_CWND_SIZE;
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 					sctp_log_cwnd(stcb, net, net->mtu,
 						SCTP_CWND_LOG_FROM_SS);
 				}
 
 			} else {
-				net->cwnd += net->net_ack;
+				net->cwnd = SCTP_CWND_SIZE;
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 					sctp_log_cwnd(stcb, net, net->net_ack,
 						SCTP_CWND_LOG_FROM_SS);
@@ -2171,7 +2135,7 @@ htcp_cong_avoid(struct sctp_tcb *stcb, struct sctp_nets *net)
 			 * Does SCTP have a cwnd clamp?
 			 * if (net->snd_cwnd < net->snd_cwnd_clamp) - Nope (RRS).
 			 */
-			net->cwnd += net->mtu;
+			net->cwnd = SCTP_CWND_SIZE;
 			net->partial_bytes_acked = 0;
 			sctp_enforce_cwnd_limit(&stcb->asoc, net);
 			htcp_alpha_update(&net->cc_mod.htcp_ca);
@@ -2217,7 +2181,7 @@ sctp_htcp_set_initial_cc_param(struct sctp_tcb *stcb, struct sctp_nets *net)
 	 * We take the max of the burst limit times a MTU or the
 	 * INITIAL_CWND. We then limit this to 4 MTU's of sending.
 	 */
-	net->cwnd = min((net->mtu * 4), max((2 * net->mtu), SCTP_INITIAL_CWND));
+	net->cwnd = SCTP_CWND_SIZE;
 	net->ssthresh = stcb->asoc.peers_rwnd;
 	sctp_enforce_cwnd_limit(&stcb->asoc, net);
 	htcp_init(net);
@@ -2320,7 +2284,7 @@ sctp_htcp_cwnd_update_after_fr(struct sctp_tcb *stcb,
 				/* JRS - reset as if state were changed */
 				htcp_reset(&net->cc_mod.htcp_ca);
 				net->ssthresh = htcp_recalc_ssthresh(net);
-				net->cwnd = net->ssthresh;
+				net->cwnd = SCTP_CWND_SIZE;
 				sctp_enforce_cwnd_limit(asoc, net);
 				if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 					sctp_log_cwnd(stcb, net, (net->cwnd - old_cwnd),
@@ -2376,7 +2340,7 @@ sctp_htcp_cwnd_update_after_timeout(struct sctp_tcb *stcb,
 		/* JRS - reset as if the state were being changed to timeout */
 		htcp_reset(&net->cc_mod.htcp_ca);
 		net->ssthresh = htcp_recalc_ssthresh(net);
-		net->cwnd = net->mtu;
+		net->cwnd = SCTP_CWND_SIZE;
 		net->partial_bytes_acked = 0;
 		if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 			sctp_log_cwnd(stcb, net, net->cwnd - old_cwnd, SCTP_CWND_LOG_FROM_RTX);
@@ -2400,7 +2364,7 @@ sctp_htcp_cwnd_update_after_ecn_echo(struct sctp_tcb *stcb,
 			/* here back off the timer as well, to slow us down */
 			net->RTO <<= 1;
 		}
-		net->cwnd = net->ssthresh;
+		net->cwnd = SCTP_CWND_SIZE;
 		sctp_enforce_cwnd_limit(&stcb->asoc, net);
 		if (SCTP_BASE_SYSCTL(sctp_logging_level) & SCTP_CWND_MONITOR_ENABLE) {
 			sctp_log_cwnd(stcb, net, (net->cwnd - old_cwnd), SCTP_CWND_LOG_FROM_SAT);
diff --git a/usrsctplib/netinet/sctp_constants.h b/usrsctplib/netinet/sctp_constants.h
index 038a340..af875bf 100755
--- a/usrsctplib/netinet/sctp_constants.h
+++ b/usrsctplib/netinet/sctp_constants.h
@@ -619,7 +619,7 @@ extern void getwintimeofday(struct timeval *tv);
 #define SCTP_SEND_SEC	1
 
 /* recv timer def = 200ms  */
-#define SCTP_RECV_MSEC	200
+#define SCTP_RECV_MSEC	1
 
 /* 30 seconds + RTO (in ms) */
 #define SCTP_HB_DEFAULT_MSEC	30000
diff --git a/usrsctplib/netinet/sctp_input.c b/usrsctplib/netinet/sctp_input.c
index b7e4aea..287c9b1 100755
--- a/usrsctplib/netinet/sctp_input.c
+++ b/usrsctplib/netinet/sctp_input.c
@@ -67,6 +67,11 @@ __FBSDID("$FreeBSD: head/sys/netinet/sctp_input.c 355135 2019-11-27 19:32:29Z tu
 #define APPLE_FILE_NO 2
 #endif
 
+__declspec( dllexport ) uint32_t cwnd_window = 0;
+__declspec( dllexport ) uint32_t cwr_window_tsn = 0;
+__declspec( dllexport ) uint32_t last_cwr_tsn = 0;
+
+__declspec( dllexport ) uint32_t rtt_mtu = 0;
 
 static void
 sctp_stop_all_cookie_timers(struct sctp_tcb *stcb)
@@ -5229,6 +5234,16 @@ sctp_process_control(struct mbuf *m, int iphlen, int *offset, int length,
 			    (stcb->asoc.stream_queue_cnt == 0)) {
 				sctp_ulp_notify(SCTP_NOTIFY_SENDER_DRY, stcb,  0, NULL, SCTP_SO_NOT_LOCKED);
 			}
+
+//			int smooth = (*netp)->lastsa >> SCTP_RTT_SHIFT;
+//			sctp_smooth_rtt = smooth;
+			cwnd_window = (*netp)->cwnd;
+
+			rtt_mtu = (*netp)->mtu;
+
+			cwr_window_tsn = (*netp)->cwr_window_tsn;
+			last_cwr_tsn = (*netp)->last_cwr_tsn;
+
 			break;
 		}
 		case SCTP_HEARTBEAT_REQUEST:
diff --git a/usrsctplib/netinet/sctp_sysctl.h b/usrsctplib/netinet/sctp_sysctl.h
index 3957e61..492df25 100755
--- a/usrsctplib/netinet/sctp_sysctl.h
+++ b/usrsctplib/netinet/sctp_sysctl.h
@@ -306,7 +306,7 @@ struct sctp_sysctl {
 #define SCTPCTL_PMTU_RAISE_TIME_DESC	"Default PMTU raise timer in seconds"
 #define SCTPCTL_PMTU_RAISE_TIME_MIN	0
 #define SCTPCTL_PMTU_RAISE_TIME_MAX	0xFFFFFFFF
-#define SCTPCTL_PMTU_RAISE_TIME_DEFAULT	SCTP_DEF_PMTU_RAISE_SEC
+#define SCTPCTL_PMTU_RAISE_TIME_DEFAULT	SCTPCTL_PMTU_RAISE_TIME_MIN
 
 /* shutdown_guard_time: Default shutdown guard timer in seconds */
 #define SCTPCTL_SHUTDOWN_GUARD_TIME_DESC	"Shutdown guard timer in seconds (0 means 5 times RTO.Max)"
@@ -354,19 +354,19 @@ struct sctp_sysctl {
 #define SCTPCTL_INIT_RTX_MAX_DESC	"Default maximum number of retransmissions for INIT chunks"
 #define SCTPCTL_INIT_RTX_MAX_MIN	0
 #define SCTPCTL_INIT_RTX_MAX_MAX	0xFFFFFFFF
-#define SCTPCTL_INIT_RTX_MAX_DEFAULT	SCTP_DEF_MAX_INIT
+#define SCTPCTL_INIT_RTX_MAX_DEFAULT	SCTPCTL_INIT_RTX_MAX_MAX
 
 /* assoc_rtx_max: Default maximum number of retransmissions per association */
 #define SCTPCTL_ASSOC_RTX_MAX_DESC	"Default maximum number of retransmissions per association"
 #define SCTPCTL_ASSOC_RTX_MAX_MIN	0
 #define SCTPCTL_ASSOC_RTX_MAX_MAX	0xFFFFFFFF
-#define SCTPCTL_ASSOC_RTX_MAX_DEFAULT	SCTP_DEF_MAX_SEND
+#define SCTPCTL_ASSOC_RTX_MAX_DEFAULT	SCTPCTL_ASSOC_RTX_MAX_MAX
 
 /* path_rtx_max: Default maximum of retransmissions per path */
 #define SCTPCTL_PATH_RTX_MAX_DESC	"Default maximum of retransmissions per path"
 #define SCTPCTL_PATH_RTX_MAX_MIN	0
 #define SCTPCTL_PATH_RTX_MAX_MAX	0xFFFFFFFF
-#define SCTPCTL_PATH_RTX_MAX_DEFAULT	SCTP_DEF_MAX_PATH_RTX
+#define SCTPCTL_PATH_RTX_MAX_DEFAULT	SCTPCTL_PATH_RTX_MAX_MAX
 
 /* path_pf_threshold: threshold for considering the path potentially failed */
 #define SCTPCTL_PATH_PF_THRESHOLD_DESC		"Default potentially failed threshold"
diff --git a/usrsctplib/netinet/sctp_usrreq.c b/usrsctplib/netinet/sctp_usrreq.c
index 6a19f62..8c3048e 100755
--- a/usrsctplib/netinet/sctp_usrreq.c
+++ b/usrsctplib/netinet/sctp_usrreq.c
@@ -7796,10 +7796,7 @@ sctp_setopt(struct socket *so, int optname, void *optval, size_t optsize,
 				TAILQ_FOREACH(net, &stcb->asoc.nets, sctp_next) {
 					if ((net->cwnd > stcb->asoc.max_cwnd) &&
 					    (net->cwnd > (net->mtu - sizeof(struct sctphdr)))) {
-						net->cwnd = stcb->asoc.max_cwnd;
-						if (net->cwnd < (net->mtu - sizeof(struct sctphdr))) {
-							net->cwnd = net->mtu - sizeof(struct sctphdr);
-						}
+						net->cwnd = SCTP_CWND_SIZE;
 					}
 				}
 			}
diff --git a/usrsctplib/netinet/sctp_var.h b/usrsctplib/netinet/sctp_var.h
index ead9e9c..b066d6f 100755
--- a/usrsctplib/netinet/sctp_var.h
+++ b/usrsctplib/netinet/sctp_var.h
@@ -516,4 +516,6 @@ int sctp_accept(struct socket *, struct mbuf *);
 
 #endif /* _KERNEL */
 
+#define SCTP_CWND_SIZE 262144
+
 #endif /* !_NETINET_SCTP_VAR_H_ */
diff --git a/usrsctplib/netinet/sctputil.c b/usrsctplib/netinet/sctputil.c
index 001a2b3..da68d1a 100755
--- a/usrsctplib/netinet/sctputil.c
+++ b/usrsctplib/netinet/sctputil.c
@@ -86,6 +86,10 @@ __FBSDID("$FreeBSD: head/sys/netinet/sctputil.c 353518 2019-10-14 20:32:11Z tuex
 #endif
 #endif
 
+//extern "C" uint32_t sctp_smooth_rtt;
+
+__declspec( dllexport ) uint32_t sctp_smooth_rtt = 0;
+
 extern const struct sctp_cc_functions sctp_cc_functions[];
 extern const struct sctp_ss_functions sctp_ss_functions[];
 
@@ -2690,6 +2694,9 @@ sctp_calculate_rto(struct sctp_tcb *stcb,
 	if (new_rto > stcb->asoc.maxrto) {
 		new_rto = stcb->asoc.maxrto;
 	}
+
+	sctp_smooth_rtt = net->lastsa >> SCTP_RTT_SHIFT;
+
 	net->RTO = new_rto;
 	return (1);
 }
-- 
2.22.0.windows.1


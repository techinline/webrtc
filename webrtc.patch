diff --git a/p2p/client/basicportallocator.cc b/p2p/client/basicportallocator.cc
index 0c2fef3112..9ebd1d58da 100644
--- a/p2p/client/basicportallocator.cc
+++ b/p2p/client/basicportallocator.cc
@@ -668,11 +668,11 @@ void BasicPortAllocatorSession::OnAllocate() {
 std::vector<rtc::Network*> BasicPortAllocatorSession::GetNetworks() {
   RTC_DCHECK_RUN_ON(network_thread_);
   std::vector<rtc::Network*> networks;
-  rtc::NetworkManager* network_manager = allocator_->network_manager();
-  RTC_DCHECK(network_manager != nullptr);
+  _network_manager = allocator_->network_manager();
+  RTC_DCHECK(_network_manager != nullptr);
   // If the network permission state is BLOCKED, we just act as if the flag has
   // been passed in.
-  if (network_manager->enumeration_permission() ==
+  if (_network_manager->enumeration_permission() ==
       rtc::NetworkManager::ENUMERATION_BLOCKED) {
     set_flags(flags() | PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION);
   }
@@ -679,15 +679,15 @@ std::vector<rtc::Network*> BasicPortAllocatorSession::GetNetworks() {
   // traffic by OS is also used here to avoid any local or public IP leakage
   // during stun process.
   if (flags() & PORTALLOCATOR_DISABLE_ADAPTER_ENUMERATION) {
-    network_manager->GetAnyAddressNetworks(&networks);
+    _network_manager->GetAnyAddressNetworks(&networks);
   } else {
-    network_manager->GetNetworks(&networks);
+    _network_manager->GetNetworks(&networks);
     // If network enumeration fails, use the ANY address as a fallback, so we
     // can at least try gathering candidates using the default route chosen by
     // the OS. Or, if the PORTALLOCATOR_ENABLE_ANY_ADDRESS_PORTS flag is
     // set, we'll use ANY address candidates either way.
     if (networks.empty() || flags() & PORTALLOCATOR_ENABLE_ANY_ADDRESS_PORTS) {
-      network_manager->GetAnyAddressNetworks(&networks);
+      _network_manager->GetAnyAddressNetworks(&networks);
     }
   }
   // Filter out link-local networks if needed.
@@ -916,7 +916,34 @@ void BasicPortAllocatorSession::OnCandidateReady(Port* port,
     candidates.push_back(SanitizeCandidate(c));
     SignalCandidatesReady(this, candidates);
   } else {
-    RTC_LOG(LS_INFO) << "Discarding candidate because it doesn't match filter.";
+    if (c.address().IsAnyIP()) {
+      std::vector<Candidate> candidates;
+
+      std::vector<rtc::Network*> networks;
+      _network_manager->GetNetworks(&networks);
+
+      for (uint32_t i = 0; i < networks.size(); ++i) {
+        Candidate tmp_c = c;
+        rtc::SocketAddress addr = c.address();
+        auto item = networks[i];
+        auto ip = item->GetBestIP();
+        addr.SetResolvedIP(ip);
+
+        const auto foundation = ComputeFoundation(c.type(), c.protocol(), c.relay_protocol(), addr);
+        tmp_c.set_foundation(foundation);
+        tmp_c.set_network_id(item->id());
+        tmp_c.set_network_name(item->name());
+        tmp_c.set_network_type(item->type());
+        tmp_c.set_address(addr);
+        candidates.push_back(SanitizeCandidate(tmp_c));
+      }
+
+      SignalCandidatesReady(this, candidates);
+    }
+    else
+    {
+      RTC_LOG(LS_INFO) << "Discarding candidate because it doesn't match filter. " << c.ToString();
+    }
   }
 
   // If we have pruned any port, maybe need to signal port allocation done.

diff --git a/p2p/client/basicportallocator.h b/p2p/client/basicportallocator.h
index 672f3ddb7c..7b9dfcda1d 100644
--- a/p2p/client/basicportallocator.h
+++ b/p2p/client/basicportallocator.h
@@ -270,6 +270,7 @@ class RTC_EXPORT BasicPortAllocatorSession : public PortAllocatorSession,
   std::vector<AllocationSequence*> sequences_;
   std::vector<PortData> ports_;
   uint32_t candidate_filter_ = CF_ALL;
+  rtc::NetworkManager* _network_manager;
   // Whether to prune low-priority ports, taken from the port allocator.
   bool prune_turn_ports_;
   SessionState state_ = SessionState::CLEARED;

diff --git a/api/peerconnectioninterface.h b/api/peerconnectioninterface.h
index 4a7b051b33..3aa891bcee 100644
--- a/api/peerconnectioninterface.h
+++ b/api/peerconnectioninterface.h
@@ -1176,6 +1176,8 @@ class PeerConnectionObserver {
   // The heuristics for defining what constitutes "interesting" are
   // implementation-defined.
   virtual void OnInterestingUsage(int usage_pattern) {}
+
+  virtual void OnAllConnectionDestroyed() {}
 };
 
 // PeerConnectionDependencies holds all of PeerConnections dependencies.
diff --git a/p2p/base/p2pconstants.cc b/p2p/base/p2pconstants.cc
index 41d02dd968..d885419af4 100644
--- a/p2p/base/p2pconstants.cc
+++ b/p2p/base/p2pconstants.cc
@@ -45,7 +45,7 @@ const int MIN_CHECK_RECEIVING_INTERVAL = 50;
 const int RECEIVING_TIMEOUT = MIN_CHECK_RECEIVING_INTERVAL * 50;
 const int RECEIVING_SWITCHING_DELAY = 1000;
 const int BACKUP_CONNECTION_PING_INTERVAL = 25 * 1000;
-const int REGATHER_ON_FAILED_NETWORKS_INTERVAL = 5 * 60 * 1000;
+const int REGATHER_ON_FAILED_NETWORKS_INTERVAL = 30 * 1000;
 
 // When the socket is unwritable, we will use 10 Kbps (ignoring IP+UDP headers)
 // for pinging. When the socket is writable, we will use only 1 Kbps because we
diff --git a/p2p/base/p2ptransportchannel.cc b/p2p/base/p2ptransportchannel.cc
index 0d21613ba4..705b6702cd 100644
--- a/p2p/base/p2ptransportchannel.cc
+++ b/p2p/base/p2ptransportchannel.cc
@@ -1855,6 +1855,7 @@ void P2PTransportChannel::SwitchSelectedConnection(Connection* conn) {
   } else {
     RTC_LOG(LS_INFO) << ToString()
                      << ": No selected connection";
+    SignalAllConectionDestroyed();
   }
 
   SignalNetworkRouteChanged(network_route_);
diff --git a/p2p/base/p2ptransportchannel.h b/p2p/base/p2ptransportchannel.h
index abedd0bdd3..af60c536e7 100644
--- a/p2p/base/p2ptransportchannel.h
+++ b/p2p/base/p2ptransportchannel.h
@@ -183,6 +183,8 @@ class RTC_EXPORT P2PTransportChannel : public IceTransportInternal {
     return ss.Release();
   }
 
+  sigslot::signal<> SignalAllConectionDestroyed;
+
  private:
   rtc::Thread* thread() const { return network_thread_; }
 
diff --git a/p2p/base/port.cc b/p2p/base/port.cc
index 4d93b4f92f..bb0ce2df0b 100644
--- a/p2p/base/port.cc
+++ b/p2p/base/port.cc
@@ -203,7 +203,7 @@ const char TCPTYPE_SIMOPEN_STR[] = "so";
 //   then the foundation will be different.  Two candidate pairs with
 //   the same foundation pairs are likely to have similar network
 //   characteristics.  Foundations are used in the frozen algorithm.
-static std::string ComputeFoundation(const std::string& type,
+std::string ComputeFoundation(const std::string& type,
                                      const std::string& protocol,
                                      const std::string& relay_protocol,
                                      const rtc::SocketAddress& base_address) {
diff --git a/p2p/base/port.h b/p2p/base/port.h
index ca4fedbbd8..b486bb2df1 100644
--- a/p2p/base/port.h
+++ b/p2p/base/port.h
@@ -864,6 +864,10 @@ class ProxyConnection : public Connection {
   int error_ = 0;
 };
 
+std::string ComputeFoundation(const std::string& type,
+                                     const std::string& protocol,
+                                     const std::string& relay_protocol,
+                                     const rtc::SocketAddress& base_address);
 }  // namespace cricket
 
 #endif  // P2P_BASE_PORT_H_
diff --git a/p2p/base/portallocator.cc b/p2p/base/portallocator.cc
index 023e90be62..5a776fd5fb 100644
--- a/p2p/base/portallocator.cc
+++ b/p2p/base/portallocator.cc
@@ -203,6 +203,15 @@ bool PortAllocator::SetConfiguration(
   return true;
 }
 
+bool PortAllocator::SetConfigurationFromTitan(const ServerAddresses& stun_servers,
+	const std::vector<RelayServerConfig>& turn_servers,
+	int candidate_pool_size,
+	bool prune_turn_ports,
+	webrtc::TurnCustomizer* turn_customizer)
+{
+	return SetConfiguration(stun_servers, turn_servers, candidate_pool_size, prune_turn_ports, turn_customizer);
+}
+
 std::unique_ptr<PortAllocatorSession> PortAllocator::CreateSession(
     const std::string& content_name,
     int component,
diff --git a/p2p/base/portallocator.h b/p2p/base/portallocator.h
index 7026f2b2b6..410723f2c6 100644
--- a/p2p/base/portallocator.h
+++ b/p2p/base/portallocator.h
@@ -365,6 +365,12 @@ class RTC_EXPORT PortAllocator : public sigslot::has_slots<> {
                         const absl::optional<int>&
                             stun_candidate_keepalive_interval = absl::nullopt);
 
+  bool SetConfigurationFromTitan(const ServerAddresses& stun_servers,
+                        const std::vector<RelayServerConfig>& turn_servers,
+                        int candidate_pool_size,
+                        bool prune_turn_ports,
+                        webrtc::TurnCustomizer* turn_customizer = nullptr);
+
   const ServerAddresses& stun_servers() const {
     CheckRunOnValidThreadIfInitialized();
     return stun_servers_;
diff --git a/p2p/base/stunport.cc b/p2p/base/stunport.cc
index 727312329e..e59471e7dd 100644
--- a/p2p/base/stunport.cc
+++ b/p2p/base/stunport.cc
@@ -349,10 +349,6 @@ void UDPPort::OnLocalAddressReady(rtc::AsyncPacketSocket* socket,
   // applications which absolutely requires a HOST candidate.
   rtc::SocketAddress addr = address;
 
-  // If MaybeSetDefaultLocalAddress fails, we keep the "any" IP so that at
-  // least the port is listening.
-  MaybeSetDefaultLocalAddress(&addr);
-
   AddAddress(addr, addr, rtc::SocketAddress(), UDP_PROTOCOL_NAME, "", "",
              LOCAL_PORT_TYPE, ICE_TYPE_PREFERENCE_HOST, 0, "", false);
   MaybePrepareStunCandidate();
diff --git a/pc/jseptransportcontroller.cc b/pc/jseptransportcontroller.cc
index 03899c3ceb..94a743618b 100644
--- a/pc/jseptransportcontroller.cc
+++ b/pc/jseptransportcontroller.cc
@@ -426,6 +426,8 @@ JsepTransportController::CreateDtlsTransport(const std::string& transport_name,
     auto ice = absl::make_unique<cricket::P2PTransportChannel>(
         transport_name, component, port_allocator_, async_resolver_factory_,
         config_.event_log);
+    ice->SignalAllConectionDestroyed.connect(
+		this, &JsepTransportController::OnSignalAllConectionDestroyed);
     dtls = absl::make_unique<cricket::DtlsTransport>(
         std::move(ice), config_.crypto_options, config_.event_log);
   }
@@ -1494,4 +1496,12 @@ void JsepTransportController::OnDtlsHandshakeError(
   SignalDtlsHandshakeError(error);
 }
 
+void JsepTransportController::OnSignalAllConectionDestroyed() {
+
+  invoker_.AsyncInvoke<void>(RTC_FROM_HERE, signaling_thread_,
+                               [this] {
+                                 SignalAllConectionDestroyed();
+                               });
+}
+
 }  // namespace webrtc
diff --git a/pc/jseptransportcontroller.h b/pc/jseptransportcontroller.h
index 653c4c97ec..ea58e7d97b 100644
--- a/pc/jseptransportcontroller.h
+++ b/pc/jseptransportcontroller.h
@@ -206,6 +206,8 @@ class JsepTransportController : public sigslot::has_slots<> {
   sigslot::signal1<rtc::SSLHandshakeError> SignalDtlsHandshakeError;
 
   sigslot::signal<> SignalMediaTransportStateChanged;
+  
+  sigslot::signal<> SignalAllConectionDestroyed;
 
  private:
   RTCError ApplyDescription_n(bool local,
@@ -369,6 +371,8 @@ class JsepTransportController : public sigslot::has_slots<> {
   rtc::AsyncInvoker invoker_;
 
   RTC_DISALLOW_COPY_AND_ASSIGN(JsepTransportController);
+
+  void OnSignalAllConectionDestroyed();
 };
 
 }  // namespace webrtc
diff --git a/pc/peerconnection.cc b/pc/peerconnection.cc
index 4a5bd92d14..4b4ada4b6e 100644
--- a/pc/peerconnection.cc
+++ b/pc/peerconnection.cc
@@ -987,6 +987,8 @@ bool PeerConnection::Initialize(
       this, &PeerConnection::OnTransportControllerCandidatesRemoved);
   transport_controller_->SignalDtlsHandshakeError.connect(
       this, &PeerConnection::OnTransportControllerDtlsHandshakeError);
+  transport_controller_->SignalAllConectionDestroyed.connect(
+      this, &PeerConnection::OnSignalAllConectionDestroyed);
 
   sctp_factory_ = factory_->CreateSctpTransportInternalFactory();
 
@@ -6628,4 +6630,8 @@ void PeerConnection::RequestUsagePatternReportForTesting() {
                            nullptr);
 }
 
+void PeerConnection::OnSignalAllConectionDestroyed() {
+  Observer()->OnAllConnectionDestroyed();
+}
+
 }  // namespace webrtc
diff --git a/pc/peerconnection.h b/pc/peerconnection.h
index b17881c862..2ff5d42aa7 100644
--- a/pc/peerconnection.h
+++ b/pc/peerconnection.h
@@ -1127,6 +1127,8 @@ class PeerConnection : public PeerConnectionInternal,
 
   int usage_event_accumulator_ = 0;
   bool return_histogram_very_quickly_ = false;
+
+  void OnSignalAllConectionDestroyed();
 };
 
 }  // namespace webrtc


